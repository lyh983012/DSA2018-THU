数据结构：
	使用了图（实际上是有向无环图），以及DFS
算法：

本题实现有以下几个重点：
1、存储连接信息：因为图较为稀疏，使用邻接表存储，在节点类中存储邻接表的头指针，在边类中存储经过此路能获得的profit值。
2、DFS方法：将图的指针（节点数组）和当前入口节点指针作为参数进行DFS，在搜索过程中存储全剧最大值以及对应节点。
3、节点类的信息存储：存储：出度、入度、产生最大利润的父亲节点，本节点的index。
4、动态规划：为了防止大量重复的路径的几算，在DFS中，每个节点额外存储【从本节点开始能获得的最大利润】，这个值当且仅当从它开始能到达的所有分支都已经走过之后才会变为非0，在递归中进行更新，相当于动态规划中的状态转移的思想。
5、实现流程：
	1）逐个读入边，起点使出度++，重点使入读++，添加一个边对象，并且存储对应的profit
	2）从每一个零入度的点开始DFS，通过邻接表遍历它的子孙，如果子孙已经有maxprofit值，可以直接返回，计算这条路上所能得到的最大利润，如果不是，那么以这个child进行下一步DFS，直到所有的点都已经生成了属于自己的Maxprofit，其中，为了使得字典序最小，在判断大小时，如果相等，优先取字典序小的点。在搜索过程中存储最大值对应的终点的地址以及全局最大值。
	3）通过产生最大利润的父亲节点这一信息寻找父节点，逆序输出对应的index，得到字典序最小且利润最大的序列。


时间复杂度估计：
	e是边的数量 ，n是节点的数量
	数据的读入需要O(n+e)的时间，进一步地，O（3e+n)。
	对于全部的DFS，对每一条路径，最多只会访问一次，更具体地，对于每一条边都只会访问最多一次，这次访问如果发现end节点已经生成了maxprofit，那	么直接返回值，如果没有生成，那么进入这个节点进行DFS。如果这条边被访问，说明上一个点正在寻找自己的maxprofit，那么访问一次之后就不会再进这	条边。这样说明DFS的时间复杂度应当是O(e）的，对于节点，每次访问一条边必定访问一个节点，所以对节点的访问也是O(e）的。
	输出是O(n）的
	故是O(n+e)的时间复杂度

空间复杂度估计：
	存储节点和边一共有
	O(n+e)的空间