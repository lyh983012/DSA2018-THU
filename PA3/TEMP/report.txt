数据结构：
	最开始，使用了一个四叉搜索树，将空间划分为四个象限，发现会超时。
	然后想要尝试range tree，实际上range tree和树状数组的思路很像，都是讲一个范围内的数进行存储，不同的是，树状数组充分利用了数据之间的相关性和独立性，把前缀和转化为logn个数字的和相加。而range tree则构建一刻平衡二叉树，在范围的查找中需要对线段进行分割。所以range tree思路简单，但实际上耗时更多一些。
	模仿range tree的思路，可以很快理解树状数组。题目中，我借鉴了一篇博客怼一维树状数组的构造方法，主要是对于lowbit函数的理解（因为它在树状数组实现中大大简化了程序），将每一个维度向另外一个方向进行拓展，建立二维的树状数组，每一个维度上的第二维树状数组都存储着一个范围内（以零和x，y为对角线）的前缀和，从而完成了优化。

算法：

本题实现有以下几个重点：
1、通过n*m个点构造树状数组
	1）申请了（n+1）*(m+1)的二维数组进行存储，将temp数组赋值给树状数组，然后将x=0和y=0的情况都赋值维0（处理边界情况）
	3）构造每个x对应的y方向的树状数组，即对于每个x，在y方向以原有元素构造树状数组
	3）回到x方向，将y方向的树状数组进行叠加，方法和一维的树状数组相同（也就是对每一个y，在x方向构造树状数组），此时y方向上的元素是一个一维的线段上的元素之和，那么叠加之后实际上就是一个矩形的元素之和。

	按照我的构造顺序，可以这么思考；
		在原来的树状数组之上，长出了以原来覆盖Δx的长度为底，高是覆盖对应的Δy的长度的矩形，这样的结构和原来的一维数组实际上是一样的，对于某一个恰好被覆盖了的Δx的范围，对于上面0～y的求和实际上就是一维数组的求和方法，那么对于0～x，0～y的矩形范围求和，就可以分为对各段Δx的y方向求和之后再次求和.

2、SUM操作：中介绍了0～x，0～y的矩形范围求和，那么对于[x1,x2]*[y1,y2], sum=[x2,y2]*[0,0]-[x1-1,y2]*[0,0]-[x2,y1-1]*[0,0]+[x1-1,y1-1]*[0,0],直接调用即可

3、修改操作：和一维数组一样，修改某个点之后，这个点将会影响其后方，作用范围（前缀范围）覆盖了它的点，对于修改，只需要逐次访问所有的点，加上这个点增加的量即可。


时间复杂度估计：
	1、构建矩阵的时间复杂度：O（n*m)。
	2、构造树状数组：在m方向上构建n个一维树状数组：O（n*2m)。在n方向上构建m个一维树状数组：O（2n*m)。
	3、计算：O（4*logn*logm)。修改：O（logn*logm)。
		计算和修改的总和是O（k*logn*logm)
	
	那么时间复杂度应该是O（k*logn*logm+mn）
	当k较大，前者为主项，为O（k*logn*logm+mn），当k较小，则后者为主项，为O（mn）

空间复杂度估计：
	存储一共花了O(mn)的空间