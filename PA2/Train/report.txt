
report包含：
所使用数据结构与算法的构思、原理和实现要点。
完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
时间和空间复杂度的估算。
（可选）介绍理论分析与实测效果的吻合程度，不吻合时进一步解释原因。
（可选）所用方法的特别、新颖或创新之处。

数据结构：
该题目很明显需要使用栈，因为每一次操纵的元素都是两个栈顶部的元素。
本题的实质就是对一个排序判断是否是能通过栈生成的一个排序，速度最快的办法就是模拟这个排序的生成，如果中途失败就直接输出No并且停止。
实现中最重要的部分就是如何维护这两个栈，为了节约空间，其中一个栈因为是自然数的一个顺序列，只需要使用一个变量wait进行自增操作即可确定对应状态参与比较的元素。另外一个栈使用数组和栈头进行维护即可。

过程中遇到的问题：
最大的问题就是如何优化时间，一开始使用限制cincout的缓存并且与sacnf，prinf解绑的方式，但是时间直接超过了1s，最后换用了是sacnf，prinf，反而快速地完成了题目要求。另外，主要的参考资料就是教材。

时间复杂度：
对序列的检查操作：每一次比较只需要常数操作，于是最好情况就是当前需要检查的排序是一个有序自然数列，在该算法之下所需时间复杂度是O（n），最坏的情况就是不断需要压栈，出栈，估计出上限，因为一个元素最多进栈一次，出栈一次，所以最坏情况是O（2n），如果是No，算法可能在2n步中的任意一步中停止，我估计平均时间复杂度也是O（n）
对序列的输出操作：和检查操作一样，但是仅仅在不出现No的情况下执行，最好的情况是O（n），最坏O（2n）
其他初始化操作：O（n）
故算法的时间复杂度最坏是O（5n），最好O（n），则O（n）

空间复杂度：使用了一个长度为n的数组和一个长度为m的数组，所以空间复杂度是O（m+n）